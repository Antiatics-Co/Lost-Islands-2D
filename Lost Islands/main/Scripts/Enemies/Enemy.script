local npc = require("main.Scripts.Modules.NPCProperties")
local window = require("main.Scripts.Modules.PlayerPosition")
local col = require("main.Scripts.Modules.CollectionTracker")

local window_width = window.getWindowWidth()
local window_height = window.getWindowHeight()

local BASE_CELL_SIZE = math.min(window_width, window_height) * 0.1
local CELL_SIZE = BASE_CELL_SIZE
local GRID_SIZE_X
local GRID_SIZE_Y
local key = nil

local function get_dynamic_cell_size()
	local go_size = false
	--local go_size = go.get(".", "size")
	if go_size then
		local object_width = go_size.x
		local object_height = go_size.y
		return math.max(BASE_CELL_SIZE, object_width * 0.1, object_height * 0.1)
	else
		print("Size property does not exist for the game object")
		return BASE_CELL_SIZE
	end
end

local function is_collision_at_position(position)
	local view_distance = npc.enemies[col.get_collection_key()][key].viewDist
	local can_move_vertically = npc.enemies[col.get_collection_key()][key].canMoveVertically
	local directions = {
		vmath.vector3(view_distance, 0, 0),  -- Right
		vmath.vector3(-view_distance, 0, 0), -- Left
		vmath.vector3(0, view_distance, 0),  -- Up
		vmath.vector3(0, -view_distance, 0)  -- Down
	}

	for _, dir in ipairs(directions) do
		local ray_start = position
		local ray_end = position + dir
		local collision_type = hash("level")
		local collision_response = physics.raycast(ray_start, ray_end, { collision_type })
		if collision_response then
			return true
		end
	end
	return false
end


local function map_to_grid(position)
	local grid_x = math.floor(position.x / CELL_SIZE) + 1
	local grid_y = math.floor(position.y / CELL_SIZE) + 1
	return vmath.vector3(grid_x, grid_y, 0)
end

function init(self)
	-- Initialization code that doesn't rely on the A* module
end

local function extract_key(go_id)
	local id_str = tostring(go_id)
	key = id_str:match("%[/(%w+)%]")
	return key
end

local function init_enemy(self)
	CELL_SIZE = get_dynamic_cell_size()
	GRID_SIZE_X = math.ceil(window_width / CELL_SIZE)
	GRID_SIZE_Y = math.ceil(window_height / CELL_SIZE)

	key = extract_key(go.get_id())
	assert(key, "Extracted key is nil. Ensure the key extraction logic is correct.")
	
	-- A* setup
	local map_width = GRID_SIZE_X
	local map_height = GRID_SIZE_Y
	local direction = astar.DIRECTION_EIGHT
	local allocate = map_width * map_height
	local typical_adjacent = 8
	local cache = true
	local flip_map = false

	astar.setup(map_width, map_height, direction, allocate, typical_adjacent, cache, flip_map)

	local map_data = {}
	for y = 1, GRID_SIZE_Y do
		map_data[y] = {}
		for x = 1, GRID_SIZE_X do
			local position = vmath.vector3((x - 0.5) * CELL_SIZE, (y - 0.5) * CELL_SIZE, 0)
			if is_collision_at_position(position) then
				map_data[y][x] = 1 -- Non-walkable tile
			else
				map_data[y][x] = 0 -- Walkable tile
			end
		end
	end

	local costs = {
		[0] = 1,
		[1] = 100
	}

	astar.set_map(map_data)
	astar.set_costs(costs)
	
	self.position = go.get_position()

	local currentCollection = col.get_collection_key()
	self.viewDist = npc.enemies[currentCollection][key].viewDist
	self.speed = npc.enemies[currentCollection][key].speed
	self.attackDist = npc.enemies[currentCollection][key].attackDist
	self.canMoveVertically = npc.enemies[currentCollection][key].canMoveVertically
	self.avoidHoles = npc.enemies[currentCollection][key].avoidHoles
	self.enraged = npc.enemies[currentCollection][key].enraged

	self.target = window.getPosition()

	local start_grid = map_to_grid(self.position)
	local goal_grid = map_to_grid(self.target)

	local result, size, total_cost, path = astar.solve(start_grid.x, start_grid.y, goal_grid.x, goal_grid.y)
	
	if result == astar.SOLVED then
		self.path = path
		self.current_step = 1
		self.recalc_timer = 0
		self.recalc_interval = 0.5
	else
		print("No path found!")
	end
end

function update(self, dt)
	local enemyPosition = go.get_position()
	local targetPosition = window.getPosition()
	local diff = vmath.length(targetPosition - enemyPosition)

	if self.viewDist ~= nil and diff ~= nil then
		if diff <= self.viewDist then
			self.recalc_timer = self.recalc_timer + dt
			if self.recalc_timer >= self.recalc_interval then
				self.target = targetPosition
				local start_grid = map_to_grid(self.position)
				local goal_grid = map_to_grid(self.target)
				local result, size, total_cost, path = astar.solve(start_grid.x, start_grid.y, goal_grid.x, goal_grid.y)
				if result == astar.SOLVED then
					self.path = path
					self.current_step = 1
					self.recalc_timer = 0
				end
			end

			if self.path and self.current_step <= #self.path then
				local next_position = self.path[self.current_step]
				local new_pos = go.get_position() + vmath.normalize(vmath.vector3((next_position.x - 0.5) * CELL_SIZE, (next_position.y - 0.5) * CELL_SIZE, 0) - go.get_position()) * self.speed * dt
				go.set_position(new_pos)
				self.current_step = self.current_step + 1
			end
		end

		if diff <= self.attackDist then
			npc.attack(key)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.group == hash("player") then
			print("Collided with player!")
		end
	end

	if message_id == hash("init_enemy") then
		init_enemy(self)
	end
end
